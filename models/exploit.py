from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator

from .base import SecurityBaseModel, NodeType, validate_confidence_score
from .vulnerability import Evidence


class ExploitNode(SecurityBaseModel):
    node_id: UUID = Field(..., description="Unique node identifier")
    type: NodeType = Field(..., description="Node type in the exploit flow")
    title: str = Field(..., description="Node title or name")
    description: str = Field(..., description="Detailed node description")
    evidence: List[Evidence] = Field(default_factory=list, description="Supporting evidence for this node")
    confidence: float = Field(..., description="Confidence score for this node")
    preconditions: List[str] = Field(default_factory=list, description="Required preconditions")
    postconditions: List[str] = Field(default_factory=list, description="Resulting conditions")
    
    @field_validator('confidence')
    @classmethod
    def validate_confidence(cls, v: float) -> float:
        return validate_confidence_score(v)


class FlowEdge(SecurityBaseModel):
    edge_id: UUID = Field(..., description="Unique edge identifier")
    source: UUID = Field(..., description="Source node ID")
    target: UUID = Field(..., description="Target node ID")
    condition: Optional[str] = Field(default=None, description="Condition for this edge")
    probability: float = Field(..., description="Probability of this transition")
    description: Optional[str] = Field(default=None, description="Edge description")
    
    @field_validator('probability')
    @classmethod
    def validate_probability(cls, v: float) -> float:
        return validate_confidence_score(v)


class ExploitFlow(SecurityBaseModel):
    name: str = Field(..., description="Exploit flow name")
    description: str = Field(..., description="Exploit flow description")
    nodes: List[ExploitNode] = Field(..., description="List of exploit nodes")
    edges: List[FlowEdge] = Field(..., description="List of flow edges")
    entry_points: List[UUID] = Field(default_factory=list, description="Entry point node IDs")
    impact_nodes: List[UUID] = Field(default_factory=list, description="Impact node IDs")
    overall_confidence: Optional[float] = Field(default=None, description="Overall flow confidence")
    
    @field_validator('overall_confidence')
    @classmethod
    def validate_overall_confidence(cls, v: Optional[float]) -> Optional[float]:
        if v is not None:
            return validate_confidence_score(v)
        return v
    
    def validate_node_references(self) -> bool:
        """Validate that all edge references point to existing nodes"""
        node_ids = {node.node_id for node in self.nodes}
        
        for edge in self.edges:
            if edge.source not in node_ids:
                raise ValueError(f"Edge source {edge.source} not found in nodes")
            if edge.target not in node_ids:
                raise ValueError(f"Edge target {edge.target} not found in nodes")
        
        for entry_id in self.entry_points:
            if entry_id not in node_ids:
                raise ValueError(f"Entry point {entry_id} not found in nodes")
        
        for impact_id in self.impact_nodes:
            if impact_id not in node_ids:
                raise ValueError(f"Impact node {impact_id} not found in nodes")
        
        return True